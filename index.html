<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/serif.css" id="theme">
		<link rel="stylesheet" href="css/custom.css">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

      <script src="lib/js/jquery-2.0.0.min.js"></script>
      <script src="lib/js/three.min.js"></script>
      <script src="lib/js/random.js"></script>
		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>
        <div id="somContainer" class="somContainerCls">
            <section id="inputGrid"></section>
            <section id="outputGrid"></section>
        </div>
		<div class="reveal">
            <div class="slides">
              <section>
                <h1>Kohnen Feature Map</h1>
                <h2>self-organizing map</h2>
                <div>SS 2013</div>
                <div>Richard Klemm (Informatik)</div>
                <div>Neuronale Netze Seminar</div>
                <div>
              </section>

              <section>
                <h2>Übersicht</h2>
                <ol>
                    <li>Einleitung</li>
                    <li>Teuvo Kohonen</li>
                    <li>Lernen</li>
                    <li>Aufbau</li>
                    <li>Begriffe</li>
                    <li>Algorithmus</li>
                    <li>Anwendungen</li>
                </ol>
              </section>

              <section>
                <h2>Einleitung</h2>
                <blockquote>
                    I just wanted an algorithm that would effectively map similar patterns (pattern vectors close to each other in the input signal space) onto contiguous locations in the output space
                </blockquote>
                <p>
                    <q cite="T.Kohonen/Self organizing maps; Preface p.VII">"It is a clustering, visualization, and abstraction method"</q>
                </p>
                <p style="text-align:right;font-size: small;">
                    T. Kohonen(Self organizing maps; Prefaxe)
                </p>
              </section>

              <section>
                <h1>Teuvo Kohonen</h1>
                <aside class="notes">
                <ul>
                    <li>11. juni 1934</li>
                    <li>Finnisch</li>
                    <li>Contributions to LVQ, Neuranalen Netzwerken</li>
                    <li>Erfinder Kohonen Self organizing map</li>
                </ul>
                </aside>
              </section>
              <section>
                <section>
                  <h1>Lernen</h1>
                  <ol>
                    <li class="fragment">Überwachtes Lernen</li>
                    <li class="fragment">Bestärkendes Lernen</li>
                    <li class="fragment fade-in">
                        <span class="fragment highlight-blue">Unüberwachtes Lernen</span>
                    </li>
                  </ol>
                </section>
                <section>
                    <h2>Unüberwachtes Lernen</h2>
                    <p class="fragment">
                    Dem System wird ein beliebiges Eingabeset präsentiert.<br>
                        <b>Es gibt keine Kontrolldaten</b>
                    </p>
                    <p class="fragment">
                        Ein Vertreter des unüberwachten Lernens ist das "competitive
                        learning
                    </p>
                </section>
                <section>
                  <h2>Was wird dann eigentlich gelernt?</h2>
                  <aside class="notes">
                  <ul>
                      <li class="fragment">Muster</li>
                      <li class="fragment">Nachbarschaft</li>
                      <li class="fragment">Abbildungen</li>
                  </ul>
                </aside>
                </section>
                <section>
                <h1>Und wie?</h1>
                </section>
              </section>

              <section>
                <h2>Aufbau</h2>
                    <div class="image">
                        <img src="images/som_aufbau_transparent.png"/>
                    </div>
              </section>
              <section>
                <section>
                  <h2>Begriffe</h2>
                </section>
                <section>
                  <h2>Winner-take-all</h2>
                        <aside class="notes">
                        <ul>
                            <li>Referenz competetive learning</li>
                        <ul>
                        </aside>
                </section>
                <section>
                    <h2>Topologie erhaltend</h2>
                    <ul>
                        <li>Begriff aus der Mathemathik (Geometry)</li>
                        <li>Beschreibt die bijektive Abbildung eines Geometry auf eine
                        andere Geometry</li>
                        <div class="image">
                            <img src="images/Mug_and_Torus.gif"/>
                        </div>
                    </ul>
                </section>
                <section>
                    <h2>Laterale Verbindungen</h2>
                    <p>Verbindungen zwischen Neuronen in einer Schicht</p>
                </section>
                  <section>
                      <h2>SOM Neuron</h2>
                      <ul>
                        <li>Feature Vector</li>
                        <li>Position</li>
                      </ul>
                        <aside class="notes">
                        <ul>
                            <li>Achtung! Lateral Connections</li>
                        <ul>
                        </aside>
                  <blockquote>
                  There are no lateral connections between nodes within the lattice.
                  </blockquote>
                  </section>
              </section>
            <section>

                <section>
                <p>Nun endlich:</p>
                <h1>Der Algorithmus</h1>
                </section>
                <section>
                    <h2>Einzeiler</h2>
                    <div class="image">
                        <img src="images/oneLineAlg.png"/>
                    </div>
                </section>
                <section>
                  <h2>Schritte</h2>
                  <ol>
                    <li class="fragment">Initalisierung</li>
                    <li class="fragment">Trainingseingabe</li>
                    <li class="fragment">Bestimmung <i>Best Matching Unit</i>(BMU)</li>
                    <li class="fragment">Gewichtsupdate</li>
                  </ol>
                </section>
                <section>
                  <h2>Initialisierung</h2>
                  <ol>
                    <li class="fragment" data-fragment-index="1">Initialisierung des 3D-Eingaberaums</li>
                    <li class="fragment" data-fragment-index="3">Zufällige Initialisierung des
                    2D-Ausgaberaums </li>
                  </ol>
                  <div class="fragment" id="initInputFrag" data-fragment-index="2"></div>
                  <div class="fragment" id="initOutputFrag" data-fragment-index="4"></div>
                </section>
                <section>
                    <h2>Trainingseingabe</h2>
                    <p class="fragment">Zufällige Auswahl von Daten aus dem
                    Eingaberaum</p>
                    <div class="fragment" id="selectInputFrag"></div>
                </section>
                <section>
                    <h2>Bestimmung BMU</h2>
                    <ol>
                        <li class="fragment" data-fragment-index="1">
                            Rotieren des Ausgaberaum für einfachere Visualisierung
                        </li>
                        <li class="fragment" data-fragment-index="3">
                            Auswahl der BMU
                            <div class="image">
                                <img src="images/minDist.png"/>
                            </div>
                        </li>
                        <aside class="notes">
                        <ul>
                            <li> es wäre schluss, bei Winner Take All</li>
                            <li>som geht weiter</li>
                        <ul>
                        </aside>
                    </ol>
                    <div class="fragment" data-fragment-index="2"
                        id="rotateOutputFrag"></div>
                    <div class="fragment" data-fragment-index="4"
                        id="highlightMatchingOutputFrag"></div>
                </section>
                <section data-state="leaveBMU">
                    <h2>Gewichtsupdate</h2>
                    <aside class="notes">
                    <ul>
                        <li>mü in wirklichkeit mü(t) * h(i,k,t)</li>
                        <li>Formel an die Tafel schreiben</li>
                    </ul>
                    </aside>

                    <div class="fragment image" data-fragment-index="1">
                            <img src="images/oneLineAlg.png"/>
                        </div>
                    <ol>
                        <li class="fragment" data-fragment-index="2">
                            Nachbarn der BMU auswählen
                        </li>
                        <li class="fragment" data-fragment-index="4">Einfluss Topologiefunktion</li>
                        <li class="fragment" data-fragment-index="6">Lernfaktor</li>
                        <li class="fragment" data-fragment-index="7">Abstand zum
                        Eingabevektor</li>
                    </ol>
                    <div class="fragment" data-fragment-index="3"
                        id="highlightNeighbours"></div>
                    <div class="fragment" data-fragment-index="5"
                        id="moveNeighbours"></div>
                    <div class="fragment" data-fragment-index="8"
                        id="weightNeighbours"></div>
                </section>
                <section>
                    <h2>Steps</h2>
                    <ol>
                        <li class="fragment" data-fragment-index="1">noch 296x</li>
                    <li  class="fragment" data-fragment-index="3">
                    some Code
                    <pre>
 <code data-trim>trainStep: () ->
    inputCube = this.selectInputCube()
    bestMatch = @outputGrid.findBestMatch(inputCube.color)
    neighbours = this.getNeighbours(bestMatch)
    this.moveCubes(neighbours)
    this.weightCubes(bestMatch, neighbours)
    @step += 1</code>
                     </pre>
                    </li>
                    </ol>
                    <div class="fragment" id="fragementFinishTraining"
                        data-fragment-index="2"</div>
                </section>

                <section>
                <h2>Zusammenfassung</h2>
                <ul>
                  <li>Abbildung eines Raumes auf einen Anderen</li>
                  <li>Beibehalten von Nachbarschaftsbeziehungen</li>
                  <li>Gut geeignet für Visualisierung</li>
                </ul>
                </section>
            </section>
            <section>
            <h1>Verbesserung</h1>
                <h2>Fast Self-Organizing Feature Map Algorithm</h2>
            <p><b>3 Stages:</b>
            <ol>
              <li>K-Means</li>
              <li>Heuristic assignment strategy</li>
              <li>Standard SOM Algorithm refinement<br/><small>Mu-Chun Su and Hsiao-Te
                  Chang</small></li>
            </ol>
            </p>
            </section>

            <section>
              <section>
                <h1>Anwendungen</h1>
                <ul>
                    <li>Data Mining</li>
                    <li>Visualisierungen</li>
                    <li>...</li>
                </ul>
              </section>
              <section>
                  <h2>Anwendungen</h2>
                  <h3>WebSOM et. al(T. Keuhonen, 2000)</h3>
                  <a href="http://websom.hut.fi/websom/milliondemo/html/root.html">
                      websom.hut.fi</a>
                  <div class="image">
                      <img src="images/websom_level0.gif"/>
                  </div>
              </section>
              <section>
                <h2>de.gnovies.com</h2>
<object data="http://www.movie-map.de/the+net.html" width="800" height="600"> <embed src=http://www.web-source.net width="600" height="400"> </embed> Error: Embedded data could not be displayed. </object>
              </section>
              <section>
                  <h2>Anwendungen</h2>
                  <h3>Viele weitere</h3>
                  <ul>
                      <li>Speedup of color palette Indexing</li>
                      <li>Analysis of Fuzzy Membership Function Generation with
                      Unsupervised Learning Using Self-Organizing Feature Map</li>
                      <li>SOFM used for Speaker-Independent Speech Recogintion</li>
                      <li>Multi-Layer Kohonen SOFM for Range Image Segementation</li>
                      <li>Image Clustering using SOFM with refinement</li>
                      <li>Amazon: Weitere Artikel für Sie</li>
                  </ul>
              </section>
              </section>
              <section>
                <h3>Vielen Dank für die Aufmerksamkeit.</h3>
                      <object width="800" height="600" data="images/chinese.svg" type="image/svg+xml" />
              </section>
            </div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

                width: 1024,
                height: 768,
                margin: 0.1,
               rollingLinks: false,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'lib/js/som.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});
            var initInput = false;
            var initOutput = false;
            var outputGrid = void 0;
            var inputGrid = void 0;
            var som = void 0;
            var selectedCube = void 0;
            var bmuCube = void 0;
            var neighbours = void 0;
            var rotateVec = new THREE.Vector3(0, 0.01, 0);
            Reveal.addEventListener( 'init-sominput', function() {
            }, false );

            Reveal.addEventListener( 'fragmentshown', function( event ) {
                if (event.fragment.id == undefined){
                    return;
                }
                if(event.fragment.id == "initInputFrag"){
                    if(!initInput){
                        initInput = true;
                        var size, sortedColor, scene;
                        size = new THREE.Vector2(300, 300);
                        sortedColor = function(colorStepX, colorStepY, colorStepZ, x, y, z) {
                          return "rgb(" + (Math.floor(colorStepX * x)) + "," + (Math.floor(colorStepY * y)) + "," + (Math.floor(colorStepZ * z)) + ")";
                        };
                        inputGrid = new Grid(new THREE.Vector3(4, 4, 4), new THREE.Vector3(90, 90, 90), sortedColor);

                        var rotate = function() {
                            inputGrid.mesh.rotation = rotateVec;
                            rotateVec.x += 0.005;
                        };
                        scene = new Scene($j('#inputGrid'), inputGrid, size, 45, rotate);
                    }
                }
                if(event.fragment.id == "initOutputFrag"){
                    if(!initOutput){
                        initOutput = true;
                        var size, randomColor, scene;
                        size = new THREE.Vector2(400, 400);
                        randomColor = function(colorStepX, colorStepY, colorStepZ, x, y, z) {
                            var r, g, b;
                            r = random.randint(0, 255);
                            g = random.randint(0, 255);
                            b = random.randint(0, 255);
                            return "rgb(" + r + "," + g + "," + b + ")";
                        };
                        outputGrid = new Grid(new THREE.Vector3(22, 22, 1),
                                new THREE.Vector3(190, 190, 10), randomColor);
                        scene = new Scene($j('#outputGrid'), outputGrid, size, 45);
                        som = new Som(inputGrid, outputGrid);
                    }
                }
                if(event.fragment.id == "selectInputFrag"){
                    selectedCube = som.selectInputCube();
                }
                if(event.fragment.id == "rotateOutputFrag"){
                    outputGrid.mesh.rotation.setX(-0.8);
                }
                if(event.fragment.id == "highlightMatchingOutputFrag"){
                    bmuCube = som.selectBestOutputCube(selectedCube);
                }
                if(event.fragment.id == "highlightNeighbours"){
                    neighbours = som.getNeighbours(bmuCube);
                    outputGrid.setCubesOpacity(0.1);
                    for (_i = 0, _len = neighbours.length; _i < _len; _i++) {
                      _ref = neighbours[_i], weight = _ref[0], cube = _ref[1];
                      cube.color.opacity = 1.0;
                    }
                }
                if(event.fragment.id == "moveNeighbours"){
                    som.moveCubes(neighbours, 4000);
                }
                if(event.fragment.id == "weightNeighbours"){
                    som.weightCubes(bmuCube, neighbours, 100);
                }
                if(event.fragment.id == "fragementFinishTraining") {
                    som.resetOpacities();
                    som.train();
                }
            } );
            Reveal.addEventListener( 'leaveBMU', function() {
                    som.resetOpacities();
            } );
		</script>
	</body>
</html>
